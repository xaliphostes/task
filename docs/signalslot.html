<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SignalSlot - Task Framework Documentation</title>
    <style>
        :root {
            --primary-color: #4a6da7;
            --secondary-color: #5e81ac;
            --accent-color: #88c0d0;
            --text-color: #2e3440;
            --text-light: #4c566a;
            --bg-color: #eceff4;
            --bg-accent: #e5e9f0;
            --success-color: #a3be8c;
            --warning-color: #ebcb8b;
            --error-color: #bf616a;
            --code-bg: #f8f9fb;
            --border-color: #d8dee9;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            max-width: 1000px;
            margin: 0 auto;
            padding: 30px;
        }

        h1,
        h2,
        h3,
        h4 {
            color: var(--primary-color);
            margin: 1.5rem 0 1rem 0;
        }

        h1 {
            font-size: 2.2rem;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--accent-color);
        }

        h2 {
            font-size: 1.8rem;
        }

        h3 {
            font-size: 1.3rem;
            color: var(--secondary-color);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--text-light);
        }

        p {
            margin-bottom: 1rem;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .feature-list {
            margin-left: 20px;
            margin-bottom: 20px;
        }

        .feature-list li {
            margin-bottom: 8px;
        }

        code {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: var(--code-bg);
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
            color: var(--secondary-color);
            border: 1px solid var(--border-color);
        }

        pre {
            background-color: var(--code-bg);
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            border: 1px solid var(--border-color);
        }

        pre code {
            background-color: transparent;
            padding: 0;
            border: none;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .table-container {
            overflow-x: auto;
            margin: 20px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1rem;
        }

        th,
        td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        thead {
            background-color: var(--bg-accent);
        }

        th {
            font-weight: 600;
            color: var(--text-light);
        }

        tr:nth-child(even) {
            background-color: rgba(229, 233, 240, 0.5);
        }

        .card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-color);
        }

        .note {
            background-color: rgba(136, 192, 208, 0.2);
            border-left: 4px solid var(--accent-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }

        .warning {
            background-color: rgba(235, 203, 139, 0.2);
            border-left: 4px solid var(--warning-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }

        .example-header {
            background-color: var(--secondary-color);
            color: white;
            padding: 10px 15px;
            border-radius: 5px 5px 0 0;
            font-weight: 500;
        }

        .example-content {
            background-color: var(--code-bg);
            padding: 15px;
            border-radius: 0 0 5px 5px;
            border: 1px solid var(--border-color);
            border-top: none;
            margin-bottom: 20px;
        }

        .section {
            margin-bottom: 40px;
        }

        .signal-type {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-left: 8px;
            background-color: var(--bg-accent);
        }

        .signal-type.simple {
            background-color: rgba(163, 190, 140, 0.3);
            color: #3b8365;
        }

        .signal-type.data {
            background-color: rgba(136, 192, 208, 0.3);
            color: #3a7b91;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        .back-link:before {
            content: "‚Üê";
            margin-right: 5px;
        }

        .inheritance {
            font-style: italic;
            margin-bottom: 15px;
            color: var(--text-light);
        }

        .toc {
            background-color: var(--bg-accent);
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 30px;
        }

        .toc h4 {
            margin-top: 0;
            margin-bottom: 10px;
        }

        .toc ul {
            list-style-type: none;
            margin-left: 10px;
        }

        .toc li {
            margin-bottom: 5px;
        }

        .toc a {
            display: inline-block;
            padding: 2px 0;
        }
    </style>
</head>

<body>
    <a href="index.html" class="back-link">Back to Index</a>

    <section class="section">
        <h1>SignalSlot</h1>
        <p class="inheritance">Base class for all Task Framework components</p>

        <div class="toc">
            <h4>Contents</h4>
            <ul>
                <li><a href="#overview">Overview</a></li>
                <li><a href="#features">Features</a></li>
                <li><a href="#interface">Class Interface</a></li>
                <li><a href="#signal-types">Signal Types</a></li>
                <li><a href="#usage">Usage Example</a></li>
                <li><a href="#argument-pack">ArgumentPack</a></li>
                <li><a href="#connections">Connection Management</a></li>
                <li><a href="#best-practices">Best Practices</a></li>
            </ul>
        </div>

        <div id="overview" class="card">
            <p>The <code>SignalSlot</code> class implements a flexible event notification system that enables loosely
                coupled communication between components. It provides a mechanism for objects to register interest in
                events (signals) and receive notifications when those events occur, without requiring direct
                dependencies between the signal emitter and receiver.</p>
            <p>This implementation supports both parameterless signals and signals with arbitrary arguments, providing a
                powerful foundation for event-driven programming patterns.</p>
        </div>

        <h2 id="features">Features</h2>
        <ul class="feature-list">
            <li><strong>Decoupled Communication:</strong> Objects can communicate without direct dependencies</li>
            <li><strong>Two Signal Types:</strong> Support for both simple (parameterless) signals and data signals
                (with arguments)</li>
            <li><strong>Type-Safe Arguments:</strong> Strong typing for signal arguments via <code>ArgumentPack</code>
            </li>
            <li><strong>Dynamic Signal Creation:</strong> Signals can be created at runtime by name</li>
            <li><strong>Method Binding:</strong> Connect signals to instance methods or free functions</li>
            <li><strong>Connection Management:</strong> Connections can be stored and disconnected when no longer needed
            </li>
            <li><strong>Resource Safety:</strong> Automatic cleanup of disconnected slots</li>
            <li><strong>Flexible Argument Passing:</strong> Support for multiple arguments of various types</li>
        </ul>

        <h2 id="interface">Class Interface</h2>
        <pre><code>class SignalSlot {
public:
    // Constructor & destructor
    SignalSlot(std::ostream &output = std::cerr);
    virtual ~SignalSlot();
    
    // Output stream control
    void setOutputStream(std::ostream &stream);
    std::ostream &stream() const;
    
    // Signal creation
    bool createSimpleSignal(const std::string &name);
    bool createDataSignal(const std::string &name);
    
    // Signal checking
    bool hasSignal(const std::string &name) const;
    SignalType getSignalType(const std::string &name) const;
    
    // Simple signal connections (no arguments)
    ConnectionHandle connectSimple(const std::string &name,
                                 std::function<void()> slot);
    template <typename T>
    ConnectionHandle connectSimple(const std::string &name, T *instance,
                                 void (T::*method)());
    
    // Data signal connections (with ArgumentPack)
    ConnectionHandle connectData(const std::string &name,
                               std::function<void(const ArgumentPack &)> slot);
    template <typename T>
    ConnectionHandle connectData(const std::string &name, T *instance,
                               void (T::*method)(const ArgumentPack &));
    
    // Signal emission
    void emit(const std::string &name); // For simple signals
    void emit(const std::string &name, const ArgumentPack &args); // For data signals
    void emitString(const std::string &name, const std::string &value); // Convenience method
    
private:
    // Internal signal access methods
    std::shared_ptr<SimpleSignal> getSimpleSignal(const std::string &name);
    std::shared_ptr<DataSignal> getDataSignal(const std::string &name);
    
    // Signal storage
    std::map<std::string, std::shared_ptr<SignalBase>> m_signals;
    std::map<std::string, SignalType> m_signal_types;
    std::reference_wrapper<std::ostream> m_output_stream;
};</code></pre>

        <h2 id="signal-types">Signal Types</h2>
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Signal Type</th>
                        <th>Class</th>
                        <th>Description</th>
                        <th>Usage</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>NO_ARGS</code></td>
                        <td><code>SimpleSignal</code></td>
                        <td>Signal with no arguments</td>
                        <td>Status changes, triggers, completion events</td>
                    </tr>
                    <tr>
                        <td><code>WITH_ARGS</code></td>
                        <td><code>DataSignal</code></td>
                        <td>Signal with <code>ArgumentPack</code> arguments</td>
                        <td>Data updates, errors with details, results</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <h2 id="usage">Usage Example</h2>
        <div class="example-header">Creating and Using Signals</div>
        <pre class="example-content"><code>// Class using the SignalSlot system
class FileDownloader : public SignalSlot {
public:
    FileDownloader() {
        // Create signals for various events
        createSimpleSignal("downloadStarted");
        createSimpleSignal("downloadCompleted");
        createDataSignal("progress");
        createDataSignal("error");
    }
    
    void startDownload(const std::string& url) {
        // Signal that download is starting
        emit("downloadStarted");
        
        try {
            // Simulate download process
            for (int i = 0; i <= 10; ++i) {
                // Report progress
                ArgumentPack progressArgs;
                progressArgs.add<float>(i / 10.0f);
                progressArgs.add<std::string>(url);
                emit("progress", progressArgs);
                
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }
            
            // Signal completion
            emit("downloadCompleted");
        }
        catch (const std::exception& e) {
            // Signal error
            emitString("error", std::string("Download failed: ") + e.what());
        }
    }
};</code></pre>

        <div class="example-header">Connecting to Signals</div>
        <pre class="example-content"><code>// Using the SignalSlot system
void downloadExample() {
    // Create the downloader
    auto downloader = std::make_shared<FileDownloader>();
    
    // Connect to signals with lambda functions
    downloader->connectSimple("downloadStarted", []() {
        std::cout << "Download has started!" << std::endl;
    });
    
    downloader->connectSimple("downloadCompleted", []() {
        std::cout << "Download completed successfully!" << std::endl;
    });
    
    downloader->connectData("progress", [](const ArgumentPack& args) {
        float progress = args.get<float>(0);
        std::string url = args.get<std::string>(1);
        std::cout << "Downloading " << url << ": " 
                 << (progress * 100) << "%" << std::endl;
    });
    
    downloader->connectData("error", [](const ArgumentPack& args) {
        std::string errorMsg = args.get<std::string>(0);
        std::cerr << "ERROR: " << errorMsg << std::endl;
    });
    
    // Start the download
    downloader->startDownload("https://example.com/file.zip");
}</code></pre>

        <h2 id="argument-pack">ArgumentPack</h2>
        <p>The <code>ArgumentPack</code> class provides a type-safe container for passing arbitrary arguments with
            signals:</p>

        <div class="example-header">Using ArgumentPack</div>
        <pre class="example-content"><code>// Creating an ArgumentPack
ArgumentPack args;
args.add<std::string>("filename.txt");
args.add<int>(42);
args.add<double>(3.14159);

// Retrieving values by index and type
std::string filename = args.get<std::string>(0);
int count = args.get<int>(1);
double value = args.get<double>(2);

// Getting the number of arguments
size_t numArgs = args.size();

// Checking if empty
bool isEmpty = args.empty();

// Cloning an ArgumentPack (deep copy)
ArgumentPack copy = args.clone();</code></pre>

        <div class="note">
            <strong>Note:</strong> Arguments are stored in the order they are added, and must be retrieved in the same
            order and with the correct type. The <code>get&lt;T&gt;(index)</code> method will throw a
            <code>std::bad_cast</code> exception if the requested type doesn't match the stored type.
        </div>

        <h2 id="connections">Connection Management</h2>
        <p>The SignalSlot system provides a <code>ConnectionHandle</code> for managing signal-slot connections:</p>

        <div class="example-header">Managing Connections</div>
        <pre class="example-content"><code>// Get a connection handle when connecting to a signal
ConnectionHandle connection = object->connectData("dataReceived", myCallback);

// Later, disconnect when no longer needed
connection->disconnect();

// Check if still connected
if (connection->connected()) {
    // ...
}</code></pre>

        <p>Connection handles use shared ownership to ensure connections are properly managed even when handlers go out
            of scope.</p>

        <h2 id="best-practices">Best Practices</h2>
        <ul class="feature-list">
            <li><strong>Signal Naming:</strong> Use descriptive signal names that clearly indicate the event (e.g.,
                "dataReceived" instead of "data")</li>
            <li><strong>Error Handling:</strong> Always handle exceptions when processing slots to prevent one handler
                from breaking others</li>
            <li><strong>Connection Management:</strong> Store connection handles for connections that need to be
                disconnected later</li>
            <li><strong>Documentation:</strong> Document the signals provided by a class, including their names and
                argument types</li>
            <li><strong>Thread Safety:</strong> Be aware that SignalSlot is not inherently thread-safe; add
                synchronization if needed</li>
            <li><strong>Resource Management:</strong> Disconnect signals when objects are destroyed to prevent dangling
                references</li>
            <li><strong>Signal Granularity:</strong> Create focused signals for specific events rather than overloading
                a single signal</li>
            <li><strong>Consistency:</strong> Maintain consistent argument order in ArgumentPack for each signal</li>
        </ul>

        <h2 id="inheritance">Inheritance and Extension</h2>
        <p>SignalSlot is designed to be inherited by classes that need to provide signal functionality:</p>

        <div class="example-header">Inheriting SignalSlot</div>
        <pre class="example-content"><code>class MyComponent : public SignalSlot {
public:
    MyComponent() {
        // Create signals during construction
        createSimpleSignal("initialized");
        createDataSignal("stateChanged");
    }
    
    void initialize() {
        // Implementation...
        emit("initialized");
    }
    
    void setState(int newState) {
        int oldState = m_state;
        m_state = newState;
        
        // Notify about state change
        ArgumentPack args;
        args.add<int>(oldState);
        args.add<int>(newState);
        emit("stateChanged", args);
    }
    
private:
    int m_state = 0;
};</code></pre>

        <h2 id="performance">Performance Considerations</h2>
        <ul class="feature-list">
            <li>Signal emission has O(n) complexity where n is the number of connected slots</li>
            <li>Connections use weak pointers internally to allow automatic cleanup</li>
            <li>Disconnected slots are removed lazily during signal emission</li>
            <li>ArgumentPack uses type erasure which involves dynamic allocation for arguments</li>
            <li>String-based signal lookup adds a small overhead compared to direct signal objects</li>
        </ul>

        <div class="note">
            <strong>Note:</strong> For high-performance scenarios with frequent signal emissions, consider optimizing by
            reducing the number of signals or batching emissions.
        </div>

        <h2 id="implementation">Implementation Details</h2>
        <ul class="feature-list">
            <li>Slots are wrapped in <code>std::function</code> objects for type erasure</li>
            <li>Signal implementations use vectors of weak pointers to connection objects</li>
            <li>Dead connections are automatically pruned during signal emission</li>
            <li>SignalSlot uses <code>std::cerr</code> by default for error reporting, but this can be changed</li>
            <li>ArgumentPack manages type information and storage using a type-erased container</li>
            <li>Connection handles use shared ownership to manage connection lifetime</li>
        </ul>

        <h2 id="advanced">Advanced Usage</h2>

        <h3>Signal Forwarding</h3>
        <p>Signals can be forwarded from one object to another:</p>

        <div class="example-header">Signal Forwarding</div>
        <pre class="example-content"><code>// Forward signals from one object to another
childObject->connectData("progress", [parentObject](const ArgumentPack& args) {
    parentObject->emit("childProgress", args);
});</code></pre>

        <h3>Custom Signal Types</h3>
        <p>The SignalSlot system can be extended with custom signal types by deriving from SignalBase:</p>

        <div class="note">
            <strong>Note:</strong> Extending the signal system with custom signal types is an advanced topic and
            requires careful implementation to maintain consistency with the existing system.
        </div>

        <h2 id="summary">Summary</h2>
        <p>The SignalSlot class provides a robust foundation for event-based communication in the Task Framework. By
            enabling loosely coupled interaction between components, it promotes modular, maintainable code structures
            that can be easily extended and modified.</p>

        <p>This implementation balances flexibility, type safety, and ease of use, making it suitable for a wide range
            of application requirements. The consistent interface across the framework ensures that all components can
            participate in the signal-slot communication system with minimal integration effort.</p>
    </section>
</body>

</html>